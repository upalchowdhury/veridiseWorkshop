# Day 3 Quiz

> Unless specified otherwise, select all applicable answers to the
> following questions.
>
> ## Question 1 (1 point)
>
> If a zk-Vanguard detector reports a warnings for a circuit, then:
>
> 1. [ ] the circuit definitely contains a bug.
> 2. [ ] the circuit might contain a bug for all possible instantiations.
> 3. [ ] the circuit definitely contains a bug but only for certain instantiations.
> 4. [ ] the circuit might contain a bug for the instantiation analyzed by Vanguard.

**ANSWER**: 4

Explanation: zk-Vanguard only analyzes a single instantiation of a circuit (excludes answer 2).
To see why answers 1 & 3 are not correct refer to the lecture from day 3.

> ## Question 2 (1 point)
>
> If a set of zk-Vanguard detectors, `D`, does not report any warning for
> a circuit, then:
>
> 1.  the circuit is bug free. You can deploy it worry-free.
> 2.  the circuit might contain some bugs for patterns searched by detectors in `D`.
> 3.  the circuit does not contain any bugs for the patterns searched by detectors in `D`.
> 4.  the circuit might contain some bugs for patterns not searched by detectors in `D`.

**ANSWER**: 3, 4

Explanation:
- Answer (1) is wrong because the circuit might contain other bugs outside the scope of detectors in `D`.
- Answer (2) is wrong because zk-Vanguard over-approximates the behavior of the circuit. So, when it doesn't report any bugs that means the circuit is safe.

## Question 3 (6 points)

This questions is about the warnings produced by zk-Vanguard for
circuit `NonZeros`. This intended behavior of this circuit is to count
the number of non-zero elements in a list of big integers.

Before answering the questions, you need to run all available
zk-Vanguard detectors for the main component in `non_zeros.circom`.

> 3a (1 point). Among the warnings generated by zk-Vanguard:
>
> 1.  All of them are spurious warnings. That is, the circuit does not contain any vulnerabilities.
> 2.  Only the warning produced by detector `uc-outputs` is an actual bug.
> 3.  The warning produced by detector `uc-outputs` and all warnings by `non-det-wit` are actual bugs.
> 4.  The warning produced by detector `uc-outputs` and some (but not all) warnings by `non-det-wit` are actual bugs.

**ANSWER**: 3

Explanation: The non-deterministic witness generation on line 25 is the source of all bugs flagged by our tool. The constraints emitted by line 26 are not sufficiently constraining `is_zero_res[i]` to equal the negation of `is_zeros[i].out`. That also makes the output signal under-constrained (`acc` is a function of `is_zero_res[i]` for all `i`'s). Since these are the only warnings emited by zk-Vanguard, and all of them are actual bugs, answer choice (3) is the correct answer and all others are incorrect.

> 3b (2 points). If there are any bugs in circuit `NonZeros`, then an attacker:
>
> 1.  can construct a proof that states input signal `ins = [[1, 0], [2, 0], [3, 0]]` does not contain any non-zero elements.
> 2.  can construct a proof that states input signal `ins = [[0, 0], [1, 0], [2, 0]]` contains three non-zero elements.
> 3.  can construct a proof that states input signal `ins = [[0, 0], [0, 0], [0, 0]]` contains three non-zero elements.
> 4.  can construct a proof that states input signal `ins = [[0, 0], [0, 0], [0, 0]]` contains four non-zero elements.

**ANSWER**: 1,2,3

Explanation: For a given witness, attackers are free to select any of the valid values for `is_zero_res[i]` (i.e., 0 and 1). So, given any list of `n_elem` numbers, an attacker can construct valid proofs for all values of the output signal `non_zeros` in the range `[0, n_elem]`. Answer choice (4) is wrong because `n_elem` is three, so it is impossible to construct a value proof that makes `non_zero` output signal equal to four.

> 3c (3 points). If you believe that circuit `NonZeros` is buggy, can you
> provide a fixed version? And remember, you can always use zk-Vanguard
> while you are developing your circuit ;)

**A possible answer:**

```
template NonZeros(n_elem, k) {

  signal input ins[n_elem][k];
  signal output non_zeros;

  component is_zeros[n_elem];

  var acc = 0;
  for (var i = 0; i < n_elem; i++) {
    is_zeros[i] = BigIsZero(k);

    for (var j = 0; j < k; j++) {
      is_zeros[i].in[j] <== ins[i][j];
    }

    acc += (1 - is_zeros[i].out);
  }

  non_zeros <== acc;
}
```

> ## Question 4 (10 points)
>
> In this question, we will examine the warning produced by zk-Vanguard,
> especially detector `uc-subcmp-outputs`, for circuit `BigSum`. As its
> name indicates, this circuit calculates the sum modulo prime `p` of a
> list of numbers. Prime `p` is a (constant) template parameter and all
> inputs are expected to be in the range of `[0, p-1]`.
>
> Before answering the questions, you need to run all available
> zk-Vanguard detectors for the main component in `big_sum.circom`.
>
> 4a (1 point). Detector `uc-subcmp-outputs` reports that `sub.underflow`
> is unconstrained in template `BigAddModP`. This warning:
>
> 1.  is definitely a vulnerability that can always be exploited by an attacker.
> 2.  reports an actual unconstrained signal. However, the circuit is not exploitable by an attacker because `sub.underflow` is not an output signal of the main component.
> 3.  is a spurious warning. That is, an attacker cannot control the value of `sub.underflow`.
> 4.  is a vulnerability that can be exploited for certain instantiations of the main component.

**ANSWER**: 3

Explanation: This is a false alarm because the number represented by array `sub.a` is guaranteed to be greater or equal than the number represented by `sub.b`. Due to the constraint on line 211, there are two cases to consider:
1. `lt.out` equals one: In this case `sub.b` is zero, so trivially `sub.a >= 0`.
2. `lt.out` equals zero: In this case `sub.b` equals to the prime represented by array `p`. However, due to the constraints from lines 200-206, we have that `add.out >= p` which in turn implies `sub.a >= sub.b`.

> 4b (1 point). Detector `uc-subcmp-outputs` reports that `eq_ands[0].out`
> is unconstrained in template `BigLessThan`. This warning:
>
> 1.  is definitely a vulnerability that can always be exploited by an attacker.
> 2.  reports an actual unconstrained signal. However, the circuit is not exploitable by an attacker because `eq_ands[0].out` is an intermediate signal.
> 3.  is a spurious warning. That is, an attacker cannot control the value of `eq_ands[0].out`.
> 4.  is a vulnerability that can be exploited for certain instantiations of the main component.

**ANSWER**: 2

Explanation: The unused signals don't affect any public inputs, so attackers can pick whatever value they see fit (eliminating answer choice (3)). However, such an attack wouldn't have any impact because the output of the template is not affected by these signals (eliminating answer choices (1) and (4)). In this case, the developer of the circuit chose to include some unused signals to simplify the logic of the template.

> 4c (1 points). Detector `uc-subcmp-outputs` reports that `lts[i].out`
> is unconstrained for `i = 0, 1, 2`. This warning:
>
> 1.  is definitely a vulnerability that can always be exploited by an attacker.
> 2.  reports an actual unconstrained signal. However, the circuit is not exploitable by an attacker because `lts[i].out` is an intermediate signal.
> 3.  is a spurious warning. That is, an attacker cannot control the value of `lts[i].out`.
> 4.  is a vulnerability that can be exploited for certain instantiations of the main component.

**ANSWER**: 1

Explanation: This is the an actual bug of the circuit. By not constraining `lts[i].out`, an attacker can pass numbers that are larger than prime p to the circuit. (See next question for more).

> 4d (2 points). If you believe that any of the above warnings are
> actual bugs, which of the following describe their impact:
>
> 1.  An attacker can create multiple proofs for the same input signals with different output signals.
> 2.  An attacker can create a proof whose output signals represent an integer bigger or equal than prime `p`.
> 3.  There are some valid proofs that cannot be verified (i.e., there is a denial-of-service issue in the verifier).
> 4.  An attacker can create a proof whose output signals represent a negative number.

**ANSWER**: 2

Explanation: Due to the bug from the previous question, an attacker could pass numbers larger than p. So, for example assume we add the following list of numbers `[p, p]`. `BigAddModP` will essentially do the following: `p + p - p`, which equals to `p`.

> 4e (5 points). Whether you believe the above circuits are buggy or
> not, can you re-write them so that zk-Vanguard no longer complains?
> Can you do that by using as few additional constraints as possible?

***Optimal Solution***: (Showing only changed templates)
```
template BigLessThan(n, k){
    signal input a[k];
    signal input b[k];
    signal output out;

    component lt[k];
    component eq[k-1];
    for (var i = 0; i < k; i++) {
        lt[i] = LessThan(n);
        lt[i].in[0] <== a[i];
        lt[i].in[1] <== b[i];
        if (i > 0) {
           eq[i-1] = IsEqual();
           eq[i-1].in[0] <== a[i];
           eq[i-1].in[1] <== b[i];
        }
    }

    // ors[i] holds (lt[k - 1] || (eq[k - 1] && lt[k - 2]) .. || (eq[k - 1] && .. && lt[i]))
    // ands[i] holds (eq[k - 1] && .. && lt[i])
    // eq_ands[i] holds (eq[k - 1] && .. && eq[i])
    component ors[k - 1];
    component ands[k - 1];
    component eq_ands[k - 2];
    for (var i = k - 2; i >= 0; i--) {
        ands[i] = AND();
        if (i > 0) {
           eq_ands[i - 1] = AND();
        }
        ors[i] = OR();

        if (i == k - 2) {
           ands[i].a <== eq[k - 2].out;
           ands[i].b <== lt[k - 2].out;
           if (i > 0) {
              eq_ands[i-1].a <== eq[k - 2].out;
              eq_ands[i-1].b <== eq[k - 3].out;
           }
           ors[i].a <== lt[k - 1].out;
           ors[i].b <== ands[i].out;
        } else {
           ands[i].a <== eq_ands[i].out;
           ands[i].b <== lt[i].out;
           if (i > 0) {
              eq_ands[i - 1].a <== eq_ands[i].out;
              eq_ands[i - 1].b <== eq[i-1].out;
           }
           ors[i].a <== ors[i + 1].out;
           ors[i].b <== ands[i].out;
        }
    }
    out <== ors[0].out;
}

template BigAddModP(n, k){
    assert(n <= 252);
    signal input a[k];
    signal input b[k];
    signal input p[k];
    signal output out[k];

    component add = BigAdd(n,k);
    for (var i = 0; i < k; i++) {
        add.a[i] <== a[i];
        add.b[i] <== b[i];
    }
    component lt = BigLessThan(n, k+1);
    for (var i = 0; i < k; i++) {
        lt.a[i] <== add.out[i];
        lt.b[i] <== p[i];
    }
    lt.a[k] <== add.out[k];
    lt.b[k] <== 0;

    component sub = BigSub(n,k+1);
    for (var i = 0; i < k; i++) {
        sub.a[i] <== add.out[i];
        sub.b[i] <== (1-lt.out) * p[i];
    }
    sub.a[k] <== add.out[k];
    sub.b[k] <== 0;

    sub.out[k] === 0;
    // Added
    sub.underflow === 0;
    for (var i = 0; i < k; i++) {
        out[i] <== sub.out[i];
    }
}


template BigSum(n_elem, n, k, p) {

  signal input ins[n_elem][k];
  signal output sum[k];

  component lts[n_elem];

  var lts_sum = 0;
  for (var i = 0; i < n_elem; i++) {
    lts[i] = BigLessThan(n, k);

    for (var j = 0; j < k; j++) {
      lts[i].a[j] <== ins[i][j];
      lts[i].b[j] <== p[j];
    }
    lts_sum += lts[i].out;
  }

  lts_sum === n_elem;

  component adds[n_elem];

  adds[0] = BigAddModP(n, k);
  for (var j = 0; j < k; j++) {
    adds[0].a[j] <== 0;
    adds[0].b[j] <== ins[0][j];
    adds[0].p[j] <== p[j];
  }

  for (var i = 1; i < n_elem; i++) {
    adds[i] = BigAddModP(n, k);

    for (var j = 0; j < k; j++) {
      adds[i].a[j] <== adds[i-1].out[j];
      adds[i].b[j] <== ins[i][j];
      adds[i].p[j] <== p[j];
    }
  }

  for (var j = 0; j < k; j++) {
    sum[j] <== adds[n_elem-1].out[j];
  }
}
```
